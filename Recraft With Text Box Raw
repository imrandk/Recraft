const box = document.createElement("div");
Object.assign(box.style, {position:"absolute",width:"300px",height:"200px",backgroundColor:"white",border:"2px solid #ccc",boxShadow:"0 4px 8px rgba(0,0,0,0.1)",top:"50px",left:"50px",resize:"both",overflow:"auto"});
const header = document.createElement("div");
Object.assign(header.style, {width:"100%",height:"30px",backgroundColor:"#007bff",color:"white",textAlign:"center",lineHeight:"30px",cursor:"move"});
header.textContent = "Drag Me";
box.appendChild(header);
const ta = document.createElement("textarea");
ta.id = "promptBoxTextarea";
Object.assign(ta.style, {width:"100%",height:"calc(100% - 30px)",border:"none",outline:"none",resize:"none",padding:"10px",fontSize:"16px"});
ta.placeholder = "Enter prompts in format:\nPrompt: Your prompt text";
box.appendChild(ta);
document.body.appendChild(box);

let isDragging = false, offsetX, offsetY;
header.addEventListener("mousedown", e => {
  isDragging = true;
  const rect = box.getBoundingClientRect();
  offsetX = e.clientX - rect.left;
  offsetY = e.clientY - rect.top;
});
document.addEventListener("mousemove", e => { if (isDragging) { box.style.left = `${e.clientX - offsetX}px`; box.style.top = `${e.clientY - offsetY}px`; } });
document.addEventListener("mouseup", () => isDragging = false);

const regex = /Prompt:\s*(.+?)(?=\n|$)/g;
let prompts = [];

function setInput(el, val) {
  try {
    Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, "value").set.call(el, val);
    el.dispatchEvent(new Event("input", { bubbles: true }));
  } catch {}
}

const click = sel => new Promise(r => {
  const btn = document.querySelector(sel);
  btn ? (btn.click(), r(true)) : r(false);
});

const waitFor = (sel, text) => new Promise(r => {
  const observer = new MutationObserver(() => {
    const el = document.querySelector(sel);
    if (el && el.textContent.trim() === text) {
      observer.disconnect();
      r(true);
    }
  });
  observer.observe(document.body, { childList: true, subtree: true, attributes: true, characterData: true });
  setTimeout(() => { observer.disconnect(); r(false); }, 30000);
});

const clickSvg = (sel, timeout = 5000) => new Promise(async r => {
  const start = Date.now();
  while (Date.now() - start < timeout) {
    const btns = document.querySelectorAll(sel);
    for (const btn of btns) {
      if (btn.textContent.trim() === "SVG") {
        btn.click();
        r(true);
        return;
      }
    }
    await new Promise(r => setTimeout(r, 100));
  }
  r(false);
});

const delay = ms => new Promise(r => setTimeout(r, ms));

const nextPrompt = () => new Promise(r => {
  const src = document.getElementById("promptBoxTextarea");
  if (prompts.length && src) {
    const val = prompts.shift();
    src.value = src.value.replace(new RegExp(`^\\s*Prompt:\\s*${val.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\s*(?:\\r?\\n)?`, "m"), "");
    const tgt = document.querySelector('textarea[data-testid="recraft-textarea"]');
    tgt ? (tgt.focus(), setInput(tgt, val), r(val)) : r(null);
  } else r(null);
});

const run = async () => {
  while (prompts.length) {
    const val = await nextPrompt();
    if (!val) break;
    if (!await click('button[data-testid="recraft-button"]')) continue;
    if (!await waitFor('button[data-testid="recraft-button"]', "Recraft")) continue;
    await click('[data-testid="recraft-topbar-export"] > [data-testid="toggler"]');
    await delay(500);
    const svgSel = "button[class*='c-bZNrxE'][class*='mode-primary']";
    if (await clickSvg(svgSel)) await delay(500);
    await click("button.c-xHEva:nth-child(2)");
    await delay(500);
    await click('[data-testid="recraft-topbar-export"] > [data-testid="toggler"]');
    await delay(500);
    if (await clickSvg(svgSel)) await delay(500);
  }
};

const check = () => {
  const src = document.getElementById("promptBoxTextarea");
  if (!src || !src.value.trim()) return false;
  prompts = [...src.value.matchAll(regex)].map(x => x[1]);
  if (prompts.length) { run(); return true; }
  return false;
};

check() || ta.addEventListener("input", () => { if (check()) ta.removeEventListener("input", this); });
